from queue import Queue as FifoQueue, LifoQueue
from typing import Protocol
from escaperoom.transcript import Transcript
from escaperoom.GameState import GameState
from escaperoom.rooms.base import Room
from escaperoom.utils import read_jsonl
import os


class TraversalCollection(Protocol):
    def get(self) -> tuple[int, list[int]]:
        ...
    def put(self, item) -> None:
        ...
    def empty(self) -> bool:
        ...

class MalwareRoom(Room):
    def __init__(self, data_dir: str):
        super().__init__("Malware Lab", "Items here: proc_tree.jsonl")
        self.path = os.path.join(data_dir, "proc_tree.jsonl")

    def solve(self, state: GameState, tr: Transcript, item: str = ""):
        if item.lower() not in ("proc_tree.jsonl", "proc", "malware", ""):
            print("Nothing interesting to inspect here.")
            return

        print("[Room Malware] Traversing process tree...")
        try:
            rows = read_jsonl(self.path)
        except FileNotFoundError:
            print("[Warning] proc_tree.jsonl not found.")
            return

        if not rows:
            print("[Warning] Empty or malformed JSONL.")
            return

        processes: dict[int, dict[str, str | int]] = {}
        children: dict[int, list[int]] = {}

        for r in rows:
            try:
                pid = int(r.get("pid", -1))
                ppid = int(r.get("ppid", -1))
                cmd = str(r.get("cmd", "")).strip()
            except Exception:
                continue
            processes[pid] = {"ppid": ppid, "cmd": cmd}
            children[ppid] = children.get(ppid, []) + [pid]

        # Get root processes (those whose ppid is not in processes)
        root = [pid for pid, metadata in processes.items() if metadata["ppid"] not in processes][0]

        found_pid, found_path, found_cmd = self.DFS_recursive(
            processes=processes,
            children=children,
            initial_pid=root
        )
        
        if found_pid == -1:
            print("[Warning] No curl/scp leaf found.")
            return

        token = str(found_pid)
        path_str = "->".join(map(str, found_path))

        tr.write(f"TOKEN[PID]={token}")
        tr.write(f"EVIDENCE[PID].PATH={path_str}")
        tr.write(f"EVIDENCE[PID].CMD={found_cmd}")

        state.tokens["PID"] = token
        print(f"Found suspicious leaf: PID={token}")
        print(f"Path: {path_str}")
        print(f"Command: {found_cmd}")
    


    def BFS_iterative(self, 
            processes: dict[int, dict[str, str | int]],
            children: dict[int, list[int]],
            initial_pid: int,
            targets: tuple[str, ...] = ("curl", "scp")
        ) -> tuple[int, list[int], str]:
        # Breadth first search -> Visit first elements to be added
        # Means that search is made by levels of depth, first nodes added are visited firstly
        collection: FifoQueue[tuple[int, list[int]]] = FifoQueue()
        collection.put(
            (initial_pid, [initial_pid])
        )
        return self._search_iterative(collection, processes, children, targets)
    
    def DFS_iterative(self, 
            processes: dict[int, dict[str, str | int]],
            children: dict[int, list[int]],
            initial_pid: int,
            targets: tuple[str, ...] = ("curl", "scp")
        ) -> tuple[int, list[int], str]:
        # Depth first search -> Visit most recent element added
        # Means that childs of most recent node are prioritized
        collection: LifoQueue[tuple[int, list[int]]] = LifoQueue()
        collection.put(
            (initial_pid, [initial_pid])
        )
        return self._search_iterative(collection, processes, children, targets)

    def _search_iterative(self, 
            base_search_collection: TraversalCollection,
            processes: dict[int, dict[str, str | int]],
            children: dict[int, list[int]],
            targets: tuple[str, ...] = ("curl", "scp")
        ) -> tuple[int, list[int], str]:
        # General tree search model which transversal mode depends on the collection passed

        queue = base_search_collection
        current_pid: int = -1
        current_path: list[int] = []
        visited: set[int] = set()

        while not queue.empty():
            current_pid, current_path = queue.get()
            print(f"Visiting {current_pid} with path {current_path}")
            if current_pid in visited:
                continue
            
            proc_metadata: dict[str, str | int] = processes[current_pid]
            cmd: str = proc_metadata["cmd"] # pyright: ignore[reportAssignmentType]
            if any(t in cmd for t in targets):
                return current_pid, current_path, cmd
            
            for child_pid in children.get(current_pid, []):
                queue.put((child_pid, [child_pid] + current_path))
            visited.add(current_pid)
        
        return (-1, [], "")

    def DFS_recursive(self,
            processes: dict[int, dict[str, str | int]],
            children: dict[int, list[int]],
            initial_pid: int,
            current_path: list[int] | None = list(),
            visited: set[int] | None = None,
            targets: tuple[str, ...] = ("curl", "scp"),
        ) -> tuple[int, list[int], str]:
        if visited is None:
            visited = set()
        
        if current_path is None:
            current_path = [initial_pid]
        
        if initial_pid in visited:
            return -1, [], ""

        print(f"Visiting {initial_pid} with path {current_path}")

        proc_metadata: dict[str, str | int] = processes[initial_pid]
        cmd: str = proc_metadata["cmd"] # pyright: ignore[reportAssignmentType]
        if any(t in cmd for t in targets):
            return initial_pid, [initial_pid], cmd

        visited.add(initial_pid)
        for child_pid in children.get(initial_pid, []):
            result = self.DFS_recursive(
                processes=processes,
                children=children,
                initial_pid=child_pid,
                current_path=current_path + [child_pid],
                visited=visited,
                targets=targets
            )
            if result[0] != -1:
                return result

        return -1, [], ""