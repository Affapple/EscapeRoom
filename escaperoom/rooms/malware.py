from queue import Queue as FifoQueue, LifoQueue
from typing import Protocol
from escaperoom.transcript import Transcript
from escaperoom.GameState import GameState
from escaperoom.rooms.base import Room
from escaperoom.utils import read_jsonl
import os


class TraversalCollection(Protocol):
    def get(self) -> tuple[int, list[int]]:
        ...
    def put(self, item) -> None:
        ...
    def empty(self) -> bool:
        ...

class MalwareRoom(Room):
    def __init__(self, data_dir: str):
        super().__init__("Malware Lab", "Items here: proc_tree.jsonl")
        self.path = os.path.join(data_dir, "proc_tree.jsonl")


    def solve(self, state: GameState, tr: Transcript, item: str = ""):
        if item.lower() not in ("proc_tree.jsonl", "proc", "malware", ""):
            print("Nothing interesting to inspect here.")
            return

        print("[Room Malware] Traversing process tree...")
        try:
            rows = read_jsonl(self.path)
        except FileNotFoundError:
            print("[Warning] proc_tree.jsonl not found.")
            return

        if not rows:
            print("[Warning] Empty or malformed JSONL.")
            return

        processes: dict[int, dict[str, str | int]] = {}
        children: dict[int, list[int]] = {}

        for r in rows:
            try:
                pid = int(r.get("pid", -1))
                ppid = int(r.get("ppid", -1))
                cmd = str(r.get("cmd", "")).strip()
            except Exception:
                continue
            processes[pid] = {"ppid": ppid, "cmd": cmd}
            children[ppid] = children.get(ppid, []) + [pid]

        # Get root processes (those whose ppid is not in processes)
        root = [pid for pid, metadata in processes.items() if metadata["ppid"] not in processes][0]
        found_pid, found_path, found_cmd = self.BFS_iterative(
            processes=processes,
            children=children,
            initial_pid=root
        )
        
        if found_pid == -1:
            print("[Warning] No curl/scp leaf found.")
            return

        token = str(found_pid)
        path_str = "->".join(map(str, found_path))

        tr.write(f"TOKEN[PID]={token}")
        tr.write(f"EVIDENCE[PID].PATH={path_str}")
        tr.write(f"EVIDENCE[PID].CMD={found_cmd}")

        state.tokens["PID"] = token
        print(f"Found suspicious leaf: PID={token}")
        print(f"Path: {path_str}")
        print(f"Command: {found_cmd}")
    

    def DFS_recursive(self,
            processes: dict[int, dict[str, str | int]],
            children: dict[int, list[int]],
            initial_pid: int,
            targets: tuple[str, ...] = ("curl", "scp"),
        ) -> tuple[int, list[int], str]:
        """Helper function to start recursive DFS search with a message."""

        print("[Room Malware] Searching process tree for malware using recursive DFS...")
        return self._DFS_recursive(
            processes=processes,
            children=children,
            initial_pid=initial_pid,
            targets=targets
        )


    def BFS_iterative(self, 
            processes: dict[int, dict[str, str | int]],
            children: dict[int, list[int]],
            initial_pid: int,
            targets: tuple[str, ...] = ("curl", "scp")
        ) -> tuple[int, list[int], str]:
        """
        Performs iterative breadth first search using a FIFO queue.
        """

        collection: FifoQueue[tuple[int, list[int]]] = FifoQueue()
        collection.put(
            (initial_pid, [initial_pid])
        )

        print("[Room Malware] Searching process tree for malware using iterative BFS...")
        return self._search_iterative(collection, processes, children, targets)
    

    def DFS_iterative(self, 
            processes: dict[int, dict[str, str | int]],
            children: dict[int, list[int]],
            initial_pid: int,
            targets: tuple[str, ...] = ("curl", "scp")
        ) -> tuple[int, list[int], str]:
        """
        Performs iterative depth first search using a LIFO queue.
        """

        collection: LifoQueue[tuple[int, list[int]]] = LifoQueue()
        collection.put(
            (initial_pid, [initial_pid])
        )

        print("[Room Malware] Searching process tree for malware using iterative DFS...")
        return self._search_iterative(collection, processes, children, targets)


    def _search_iterative(self, 
            base_search_collection: TraversalCollection,
            processes: dict[int, dict[str, str | int]],
            children: dict[int, list[int]],
            targets: tuple[str, ...] = ("curl", "scp")
        ) -> tuple[int, list[int], str]:
        """
        General Tree Search iterative implementation.
        Transversal mode depends on the collection passed (FIFO for BFS, LIFO for DFS).
        """

        queue = base_search_collection
        current_pid: int = -1
        current_path: list[int] = []
        visited: set[int] = set()

        while not queue.empty():
            current_pid, current_path = queue.get()
            if current_pid in visited:
                continue
            
            proc_metadata: dict[str, str | int] = processes[current_pid]
            cmd: str = proc_metadata["cmd"] # pyright: ignore[reportAssignmentType]
            if any(t in cmd for t in targets):
                return current_pid, current_path, cmd
            
            for child_pid in children.get(current_pid, []):
                queue.put((child_pid, current_path + [child_pid]))
            visited.add(current_pid)
        
        return (-1, [], "")

    def _DFS_recursive(self,
            processes: dict[int, dict[str, str | int]],
            children: dict[int, list[int]],
            initial_pid: int,
            current_path: list[int] | None = None,
            visited: set[int] | None = None,
            targets: tuple[str, ...] = ("curl", "scp"),
        ) -> tuple[int, list[int], str]:
        """Recursive implementation of depth first search."""

        if visited is None:
            visited = set()
        
        if current_path is None:
            current_path = [initial_pid]
        
        if initial_pid in visited:
            return -1, [], ""

        proc_metadata: dict[str, str | int] = processes[initial_pid]
        cmd: str = proc_metadata["cmd"] # pyright: ignore[reportAssignmentType]
        if any(t in cmd for t in targets):
            return initial_pid, current_path , cmd

        visited.add(initial_pid)
        for child_pid in children.get(initial_pid, []):
            result = self._DFS_recursive(
                processes=processes,
                children=children,
                initial_pid=child_pid,
                current_path=current_path + [child_pid],
                visited=visited,
                targets=targets
            )
            if result[0] != -1:
                return result

        return -1, [], ""