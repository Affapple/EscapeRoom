import os
from queue import Queue as FifoQueue, LifoQueue
from typing import Protocol

from escaperoom.transcript import Transcript
from escaperoom.GameState import GameState
from escaperoom.rooms.base import Room
from escaperoom.utils import read_jsonl


class TraversalCollection(Protocol):
    """
    Protocol for traversal collections used in tree search algorithms
    """

    def get(self) -> tuple[int, list[int]]:
        """
        Retrieves and removes an item from the collection
        """
        ...

    def put(self, item) -> None:
        """
        Adds an item to the collection
        """
        ...

    def empty(self) -> bool:
        """
        Checks if the collection is empty
        """
        ...


class MalwareRoom(Room):
    """
    Room representing a malware analysis lab with a process tree to inspect
    """

    def __init__(self, data_dir: str):
        super().__init__("Malware Lab", "Items here: proc_tree.jsonl")
        self.path = os.path.join(data_dir, "proc_tree.jsonl")

    def solve(self, state: GameState, tr: Transcript, item: str = ""):
        """
        Inspects the process tree to find suspicious processes using tree search algorithms
        :param state: Current game state
        :param tr: Transcript to log actions
        :param item: Item to inspect
        """
        if item.lower() not in ("proc_tree.jsonl", "proc", "malware", ""):
            print("Nothing interesting to inspect here.")
            return

        print("[Room Malware] Traversing process tree...")
        try:
            rows = read_jsonl(self.path)
        except FileNotFoundError:
            print("[Warning] proc_tree.jsonl not found.")
            return

        if not rows:
            print("[Warning] Empty or malformed JSONL.")
            return

        processes: dict[int, dict[str, str | int]] = {}
        children: dict[int, list[int]] = {}

        for r in rows:
            try:
                pid = int(r.get("pid", -1))
                ppid = int(r.get("ppid", -1))
                cmd = str(r.get("cmd", "")).strip()
            except ValueError:
                # Skip processes with non-integer pid/ppid
                continue
            processes[pid] = {"ppid": ppid, "cmd": cmd}
            children[ppid] = children.get(ppid, []) + [pid]

        # Get root processes (those whose ppid is not in processes)
        root = [
            pid
            for pid, metadata in processes.items()
            if metadata["ppid"] not in processes
        ][0]
        found_pid, found_path, found_cmd = self.DFS_recursive(
            processes=processes, children=children, initial_pid=root
        )

        if found_pid == -1:
            print("[Warning] No curl/scp leaf found.")
            return

        token = str(found_pid)
        path_str = "->".join(map(str, found_path))

        tr.write(f"TOKEN[PID]={token}")
        tr.write(f"EVIDENCE[PID].PATH={path_str}")
        tr.write(f"EVIDENCE[PID].CMD={found_cmd}")

        state.tokens["PID"] = token
        print(f"Found suspicious leaf: PID={token}")
        print(f"Path: {path_str}")
        print(f"Command: {found_cmd}")

    def DFS_recursive(
        self,
        processes: dict[int, dict[str, str | int]],
        children: dict[int, list[int]],
        initial_pid: int,
        targets: tuple[str, ...] = ("curl", "scp"),
    ) -> tuple[int, list[int], str]:
        """
        Recursive implementation of depth first search
        :param processes: Mapping of pid to process metadata
        :param children: Mapping of ppid to list of child pids
        :param initial_pid: PID to start the search from
        :param current_path: Current path of PIDs taken to reach this node
        :param visited: Set of visited PIDs to avoid cycles
        :param targets: Tuple of target command substrings to search for
        """

        # Define the inner recursive function
        def recursive_dfs(
            processes: dict[int, dict[str, str | int]],
            children: dict[int, list[int]],
            current_pid: int,
            current_path: list[int],
            visited: set[int],
        ) -> tuple[int, list[int], str]:
            nonlocal targets
            if current_pid in visited:
                return -1, [], ""

            proc_metadata: dict[str, str | int] = processes[current_pid]
            cmd: str = proc_metadata["cmd"]  # pyright: ignore[reportAssignmentType]
            
            # If it's malware and its a leaf node, then meets criteria
            if self._is_malware(cmd, targets) and not children.get(current_pid):
                return current_pid, current_path, cmd

            visited.add(current_pid)
            for child_pid in children.get(current_pid, []):
                result = recursive_dfs(
                    processes=processes,
                    children=children,
                    current_pid=child_pid,
                    current_path=current_path + [child_pid],
                    visited=visited,
                )
                if result[0] != -1:
                    return result
            return -1, [], ""

        print(
            "[Room Malware] Searching process tree for malware using recursive DFS..."
        )
        return recursive_dfs(
            processes=processes,
            children=children,
            current_pid=initial_pid,
            current_path=[initial_pid],
            visited=set(),
        )

    def BFS_iterative(
        self,
        processes: dict[int, dict[str, str | int]],
        children: dict[int, list[int]],
        initial_pid: int,
        targets: tuple[str, ...] = ("curl", "scp"),
    ) -> tuple[int, list[int], str]:
        """
        Performs iterative breadth first search using a FIFO queue.
        :param processes: Mapping of pid to process metadata
        :param children: Mapping of ppid to list of child pids
        :param initial_pid: PID to start the search from
        :param targets: Tuple of target command substrings to search for
        """

        collection: FifoQueue[tuple[int, list[int]]] = FifoQueue()
        collection.put((initial_pid, [initial_pid]))

        print(
            "[Room Malware] Searching process tree for malware using iterative BFS..."
        )
        return self._search_iterative(collection, processes, children, targets)

    def DFS_iterative(
        self,
        processes: dict[int, dict[str, str | int]],
        children: dict[int, list[int]],
        initial_pid: int,
        targets: tuple[str, ...] = ("curl", "scp"),
    ) -> tuple[int, list[int], str]:
        """
        Performs iterative depth first search using a LIFO queue.
        :param processes: Mapping of pid to process metadata
        :param children: Mapping of ppid to list of child pids
        :param initial_pid: PID to start the search from
        :param targets: Tuple of target command substrings to search for
        """

        collection: LifoQueue[tuple[int, list[int]]] = LifoQueue()
        collection.put((initial_pid, [initial_pid]))

        print(
            "[Room Malware] Searching process tree for malware using iterative DFS..."
        )
        return self._search_iterative(collection, processes, children, targets)

    def _search_iterative(
        self,
        base_search_collection: TraversalCollection,
        processes: dict[int, dict[str, str | int]],
        children: dict[int, list[int]],
        targets: tuple[str, ...] = ("curl", "scp"),
    ) -> tuple[int, list[int], str]:
        """
        General Tree Search iterative implementation
        Transversal mode depends on the collection passed (FIFO for BFS, LIFO for DFS)
        :param base_search_collection: The traversal collection to use
        :param processes: Mapping of pid to process metadata
        :param children: Mapping of ppid to list of child pids
        :param targets: Tuple of target command substrings to search for
        """

        queue = base_search_collection
        current_pid: int = -1
        current_path: list[int] = []
        visited: set[int] = set()

        while not queue.empty():
            current_pid, current_path = queue.get()
            if current_pid in visited:
                continue

            proc_metadata: dict[str, str | int] = processes[current_pid]
            cmd: str = str(proc_metadata["cmd"])
            if self._is_malware(cmd, targets):
                # If it's a terminal process, then meets criteria
                if not children.get(current_pid): 
                    return current_pid, current_path, cmd
                    

            for child_pid in children.get(current_pid, []):
                queue.put((child_pid, current_path + [child_pid]))
            visited.add(current_pid)

        return (-1, [], "")

    def _is_malware(self, cmd: str, targets: tuple[str, ...]) -> bool:
        """
        Checks if the command is categorized as malware
        
        :param cmd: Command string to check
        :param targets: Tuple of target command substrings to search for
        :return: True if command is potential malware, otherwise False
        """
        user_ran_cmd = not cmd.startswith(("/", "./"))
        if not user_ran_cmd:
            return False
        
        cmd = cmd.lower() # Case insensitive check
        contains_potential_extradition_cmd = any(t.lower() in cmd for t in targets)
        contains_post_request_cmd = "post" in cmd
        potential_extradition_cmd = contains_potential_extradition_cmd and contains_post_request_cmd
        if potential_extradition_cmd:
            return True
    
        return False