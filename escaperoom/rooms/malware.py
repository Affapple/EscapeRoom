from queue import Queue as FifoQueue, LifoQueue
from typing import Protocol
from escaperoom.transcript import Transcript
from escaperoom.GameState import GameState
from escaperoom.rooms.base import Room
from escaperoom.utils import read_jsonl
import os
import collections


class PopableCollection(Protocol):
    def get(self) -> tuple[int, list[int]]:
        ...
    def put(self, item) -> None:
        ...
    def empty(self) -> bool:
        ...

class MalwareRoom(Room):
    def __init__(self, data_dir: str):
        super().__init__("Malware Lab", "Items here: proc_tree.jsonl")
        self.path = os.path.join(data_dir, "proc_tree.jsonl")

    def solve(self, state: GameState, tr: Transcript, item: str = ""):
        if item.lower() not in ("proc_tree.jsonl", "proc", "malware", ""):
            print("Nothing interesting to inspect here.")
            return

        print("[Room Malware] Traversing process tree...")
        try:
            rows = read_jsonl(self.path)
        except FileNotFoundError:
            print("[Warning] proc_tree.jsonl not found.")
            return

        if not rows:
            print("[Warning] Empty or malformed JSONL.")
            return

        processes: dict[int, dict[str, str | int]] = {}
        children: dict[int, list[int]] = {}

        for r in rows:
            try:
                pid = int(r.get("pid", -1))
                ppid = int(r.get("ppid", -1))
                cmd = str(r.get("cmd", "")).strip()
            except Exception:
                continue
            processes[pid] = {"ppid": ppid, "cmd": cmd}
            children[ppid].append(pid)

        # Get root processes (those whose ppid is not in processes)
        roots = [pid for pid, metadata in processes.items() if metadata["ppid"] not in processes]

        targets = ("curl", "scp")
        visited: set[int] = set()
        queue: collections.deque[tuple[int, list[int]]] = collections.deque(
            (r, [r]) for r in sorted(roots)
        )

        found_pid, found_path, found_cmd = -1, [], ""
        while queue:
            pid, path = queue.popleft()
            if pid in visited:
                continue
            visited.add(pid)
            meta = processes.get(pid, {})
            cmd = meta.get("cmd", "")
            if any(cmd.startswith(t) for t in targets):
                found_pid, found_path, found_cmd = pid, path, cmd
                break
            for child in sorted(children.get(pid, [])):
                if child not in visited:
                    queue.append((child, path + [child]))

        if found_pid == -1:
            print("[Warning] No curl/scp leaf found.")
            return

        token = str(found_pid)
        path_str = "->".join(map(str, found_path))

        tr.write(f"TOKEN[PID]={token}")
        tr.write(f"EVIDENCE[PID].PATH={path_str}")
        tr.write(f"EVIDENCE[PID].CMD={found_cmd}")

        state.tokens["PID"] = token
        print(f"Found suspicious leaf: PID={token}")
        print(f"Path: {path_str}")
        print(f"Command: {found_cmd}")
    


    def BFS(self, 
            processes: dict[int, dict[str, str | int]],
            children: dict[int, list[int]],
            initial_pid: int,
            targets: tuple[str, ...] = ("curl", "scp")
        ) -> tuple[int, list[int], str]:
        # Breadth first search -> Visit first elements to be added
        # Means that search is made by levels of depth, first nodes added are visited firstly
        collection: FifoQueue[tuple[int, list[int]]] = FifoQueue()
        collection.put(
            (initial_pid, [initial_pid])
        )
        return self._search(collection, processes, children, targets)
    
    def DFS(self, 
            processes: dict[int, dict[str, str | int]],
            children: dict[int, list[int]],
            initial_pid: int,
            targets: tuple[str, ...] = ("curl", "scp")
        ) -> tuple[int, list[int], str]:
        # Depth first search -> Visit most recent element added
        # Means that childs of most recent node are prioritized
        collection: LifoQueue[tuple[int, list[int]]] = LifoQueue()
        collection.put(
            (initial_pid, [initial_pid])
        )
        return self._search(collection, processes, children, targets)

    def _search(self, 
            base_search_collection: PopableCollection,
            processes: dict[int, dict[str, str | int]],
            children: dict[int, list[int]],
            targets: tuple[str, ...] = ("curl", "scp")
        ) -> tuple[int, list[int], str]:
        # General tree search model which mode depends on the collection passed

        queue = base_search_collection
        current_pid: int = -1
        current_path: list[int] = []
        visited: set[int] = set()

        while not queue.empty():
            current_pid, current_path = queue.get()
            if current_pid in visited:
                continue
            
            proc_metadata: dict[str, str | int] = processes[current_pid]
            cmd: str = proc_metadata["cmd"] # pyright: ignore[reportAssignmentType]
            if any(t in cmd for t in targets):
                return current_pid, current_path, cmd
            
            for child_pid in children[current_pid]:
                queue.put((child_pid, [child_pid] + current_path))
            visited.add(current_pid)
        
        return (-1, [], "")
